
1、
glColor4f、glNormal3f等函数似乎就是一种命令，设定以后，如果之后不再设置，那么后面所有的顶点都采用之前的设置，除非更改设置。

2、
glTransltatef、glRotatef对物体进行操作时，操作的是物体本身的坐标系，而不是世界坐标系。如
glRotatef(90, 0,0,1) //单位是角度
glTransltatef(10,0,0)
那么结果是物体处在Y坐标10单位的地方。glRotatef(90, 0,0,1)先让物体按照自身的Z轴旋转90°，这个时候自身的X轴实际上已经是向上了，glTransltatef(10,0,0)朝自身的X轴移动10单位，实际上就处在实际世界的(0,10,0)地方了

3、
glCallList用来调用之前设定的显示列表，而之前指定的显示列表应该是要经过glNewList处理的，但是nehe的教程在绘制字体的时候，调用了glCallList画字体，但之前并没有字体的glNewList,不知是何缘故？

4、opengl矩阵
在opengl中，矩阵采用的是列矩阵，而directx中采用的是行矩阵，Dex引擎中的矩阵也是行矩阵。
那么如果用Dex的行矩阵操作完之后，复制给opengl,是否需要对矩阵进行一下转置呢？目前看来是不需要的。
比如，对于一个在原点，然后向x方向移动10个单位的directx行矩阵，如下
1  0  0  0
0  1  0  0
0  0  1  0
10 0  0  1，我们称之为A
，如果是opengl列矩阵，如下
1  0  0  10
0  1  0  0
0  0  1  0
0  0  0  1，我们称之为B
从数学上看来，要想让行矩阵A符合列矩阵B，必须要转置一下，但是其实无论是directx还是opengl,对于矩阵的处理，都是在内存中寻找连续存储的16个浮点数
，用这16个浮点数进行一些计算。对于directx的行矩阵来说，它希望内存中第12个浮点数表示X轴位移，而对于opengl来说，它同样希望内存中第12个浮
点数表示X轴位移，这点是一样的。对于A，由于是行矩阵，所以它在内存中存储时，是一行行存储的，10就位于第12个内存位置，对于B，由于是列矩阵，所以它
在内存中是一列列存储的，所以B里面的10也同样位于第12个内存位置，所以从数学上看，A和B互为转置矩阵，但从内存上看，二者其实是一样的。

5、关于opengl中的矩阵计算
  glLoadMatrixf(float* m)表示将矩阵堆栈最上层的值设置为m，而图形显示的依据，都以最上层的操作结果为依据。
  所以我们再对camera设置glLoadMatrixf视图矩阵之后，如果想要操作几何体，先glPushMatrix，glPushMatrix将矩阵堆栈中最上层的矩阵复制一份，放到最上层，
  也就是将camera视图矩阵拷贝了一份放到最上层，之后操作几何体时，都要先乘这个视图矩阵，即进行glMultiMatrix，把相乘结果覆盖那个拷贝的视图矩阵，这个
  矩阵也是最终显示的依据数据。操作完一个几何体之后，进行glPopMatrix，这时矩阵堆栈中只剩下camera的视图矩阵，这时如果再要操作另一个几何体，重复之前的步骤
  即可。